;; -----------------------------------------------------------------
;; File: FakeJetton.fc
;; A minimal FakeJetton (jetton master) contract for testing.
;; -----------------------------------------------------------------

#include "imports/stdlib.fc";

;; Operation codes.
const OP_INIT         = 1;   ;; Initialize storage.
const OP_GET_BALANCE  = 2;   ;; Get token balance.
const OP_TRANSFER     = 3;   ;; Transfer tokens.

;; Error code.
const ERR_INSUFFICIENT_BALANCE = 1001;

;; -----------------------------------------------------------------
;; Helper: Convert an address (slice) to an int key.
;; We store the address in a cell and compute its hash.
;; -----------------------------------------------------------------
int key_from_address(slice addr) inline {
    return cell_hash(begin_cell().store_slice(addr).end_cell());
}

;; -----------------------------------------------------------------
;; Storage:
;; We store two items:
;;   - A dictionary (as a cell) mapping int keys to a 256-bit balance (stored as a slice).
;;   - A dummy cell (stored as a ref) â€“ here we simply store an empty cell.
;; -----------------------------------------------------------------
(cell, cell) load_data() inline {
    slice s = get_data().begin_parse();
    cell dict = s~load_dict();   ;; dictionary is stored as a cell
    cell dummy = s~load_ref();
    return (dict, dummy);
}

() save_data(cell dict, cell dummy) impure inline {
    set_data(
        begin_cell()
            .store_dict(dict)
            .store_ref(dummy)
            .end_cell()
    );
}

;; -----------------------------------------------------------------
;; Initialization:
;; Expects the message body to contain the owner address.
;; Sets that owner's balance to 1,000,000 units.
;; -----------------------------------------------------------------
() initialize_storage(slice in_msg_body) impure {
    slice owner = in_msg_body~load_msg_addr();
    int initialSupply = 1000000;  ;; 1,000,000 units.
    ;; Create a new dictionary (as a slice).
    slice sdict = new_dict();
    int key = key_from_address(owner);
    ;; Update the dictionary with the initial balance.
    sdict = dict_set(sdict, key, begin_cell().store_uint(initialSupply, 256).end_cell().begin_parse());
    cell dict_cell = begin_cell().store_slice(sdict).end_cell();
    save_data(dict_cell, begin_cell().end_cell());
}

;; -----------------------------------------------------------------
;; Getter: get_balance.
;; Expects the message body to contain the caller's address.
;; Returns the balance (as a 256-bit integer).
;; -----------------------------------------------------------------
(int) get_balance(slice in_msg_body) method_id {
    slice owner = in_msg_body~load_msg_addr();
    int key = key_from_address(owner);
    cell dict_cell = load_data().0;
    slice sdict = dict_cell.begin_parse();
    var (val, found) = dict_get(sdict, key);
    if (!found) return 0;
    int balance = val~load_uint(256);
    return balance;
}

;; -----------------------------------------------------------------
;; Transfer:
;; Expects the message body to contain:
;;   - The sender address (msg sender)
;;   - The token amount (128-bit integer)
;;   - The recipient address.
;; Updates the dictionary accordingly.
;; -----------------------------------------------------------------
() transfer(slice in_msg_body) impure {
    slice sender = in_msg_body~load_msg_addr();
    int amount = in_msg_body~load_uint(128);
    slice recipient = in_msg_body~load_msg_addr();
    int senderKey = key_from_address(sender);
    int recipientKey = key_from_address(recipient);
    (cell dict_cell, cell dummy) = load_data();
    slice sdict = dict_cell.begin_parse();
    var (senderVal, found) = dict_get(sdict, senderKey);
    int senderBalance = found ? senderVal~load_uint(256) : 0;
    if (senderBalance < amount) {
        throw(ERR_INSUFFICIENT_BALANCE);
    }
    senderBalance = senderBalance - amount;
    sdict = dict_set(sdict, senderKey, begin_cell().store_uint(senderBalance, 256).end_cell().begin_parse());
    var (recipientVal, foundRec) = dict_get(sdict, recipientKey);
    int recipientBalance = foundRec ? recipientVal~load_uint(256) : 0;
    recipientBalance = recipientBalance + amount;
    sdict = dict_set(sdict, recipientKey, begin_cell().store_uint(recipientBalance, 256).end_cell().begin_parse());
    cell new_dict_cell = begin_cell().store_slice(sdict).end_cell();
    save_data(new_dict_cell, dummy);
}

;; -----------------------------------------------------------------
;; Main entry point.
;; Routes messages based on the op code in the message body.
;; -----------------------------------------------------------------
() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) return ();
    int op = in_msg_body~load_uint(32);
    if (op == OP_INIT) {
        initialize_storage(in_msg_body);
        return ();
    }
    if (op == OP_GET_BALANCE) {
        int b = get_balance(in_msg_body);
        ~dump(b);  ;; Dump balance for off-chain retrieval.
        return ();
    }
    if (op == OP_TRANSFER) {
        transfer(in_msg_body);
        return ();
    }
    throw(9999);  ;; Unknown op code.
}
