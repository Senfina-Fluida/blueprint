#include "stdlib.fc"

// Define an op code constant for internal transfers (jetton transfers)
const int INTERNAL_TRANSFER_OP = 1;

//----------------------------------------------------------------
// Storage: tokenBalance (jetton tokens held) and jetton_wallet_code
//----------------------------------------------------------------
(int, cell) load_data() inline {
    slice ds = get_data().begin_parse();
    int tokenBalance = ds~load_coins();  // stored token balance
    cell jetton_wallet_code = ds~load_ref();  // wallet blueprint code (not actively used here)
    ds.end_parse();
    return (tokenBalance, jetton_wallet_code);
}

() save_data(int tokenBalance, cell jetton_wallet_code) impure inline {
    set_data(
        begin_cell()
            .store_coins(tokenBalance)
            .store_ref(jetton_wallet_code)
            .end_cell()
    );
}

//----------------------------------------------------------------
// Helper: Load a simple header from the message body.
// We assume that the first 8 bytes of the message body represent two 32-bit integers:
// the op code and the query id.
(int, int) load_body_header(slice body) inline {
    int op = body~load_uint(32);
    int query_id = body~load_uint(32);
    return (op, query_id);
}

//----------------------------------------------------------------
// The main entry point: recv_internal
// This function is called when an internal message arrives.
// It parses the incoming message and, if it is a jetton transfer,
// updates the contract's token balance.
() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    // If no message body, do nothing.
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    
    // ---- Parse the full message header ----
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    // If the lowest bit is set, it is a bounce message; ignore it.
    if (flags & 1) {
        return ();
    }
    slice sender_address = cs~load_msg_addr();
    cs~load_msg_addr();   // Skip destination address.
    cs~load_coins();      // Skip coin amount.
    cs~skip_bits(1);      // Skip extra bits.
    cs~load_coins();      // Skip another coin field.
    // (For simplicity, we ignore forwarding fee calculations here.)
    
    // ---- Parse the message body header ----
    (int op, int query_id) = load_body_header(in_msg_body);
    
    // ---- Process the internal transfer op code ----
    if (op == INTERNAL_TRANSFER_OP) {
        // Assume that the next field in the body is the token amount (stored as coins).
        int amount = in_msg_body~load_coins();
        // For demonstration, we expect two additional fields: sender and response addresses.
        slice from_address = in_msg_body~load_msg_addr();
        slice response_address = in_msg_body~load_msg_addr();
        // (Any additional payload is ignored in this simplified example.)
        
        // Load current storage data.
        (int tokenBalance, cell wallet_code) = load_data();
        // Update token balance by adding the received token amount.
        tokenBalance += amount;
        save_data(tokenBalance, wallet_code);
        
        // Optionally, if msg_value (the attached funds) remain, send a reply to the response address.
        // This is a simplified version of "excess" handling.
        if (msg_value > 0) {
            var reply = begin_cell()
                .store_msg_flags(0) // NON_BOUNCEABLE flag can be set as needed
                .store_slice(response_address)
                .store_coins(msg_value)
                // Store a simple reply header (using query_id for tracking).
                .store_uint(query_id, 32)
                .end_cell();
            send_raw_message(reply, 0);  // Use mode 0 (regular) for sending.
        }
        return ();
    }
    
    // If the op code is not recognized, throw an error (or simply ignore).
    // In a production contract you might want to revert.
    throw(100, "Unknown operation code");
}

//----------------------------------------------------------------
// A simple public method to query the current token balance.
(int) get_token_balance() method_id {
    (int tokenBalance, cell wallet_code) = load_data();
    return tokenBalance;
}
