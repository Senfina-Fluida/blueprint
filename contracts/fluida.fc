;; -----------------------------------------------------------------
;; File: Fluida.fc
;; -----------------------------------------------------------------

#include "imports/stdlib.fc";

;; -----------------------------------------------------------------
;; Constants & Error Codes
;; -----------------------------------------------------------------
const OP_COMPLETE_SWAP    = 2271560481;  ;; decimal 0x87654321
const OP_REFUND_SWAP      = 2882400018;  ;; decimal 0xabcdef12
const OP_INITIALIZE       = 1;           ;; New initialization operation

const ERR_INVALID_AMOUNT                  = 65521; ;; 0xfff1
const ERR_INVALID_TIMELOCK                = 65522; ;; 0xfff2
const ERR_SWAP_COMPLETED                  = 65523; ;; 0xfff3
const ERR_INVALID_PREIMAGE                = 65524; ;; 0xfff4
const ERR_TIMELOCK_EXPIRED                = 65525; ;; 0xfff5
const ERR_SWAP_ALREADY_COMPLETED_REFUND   = 65526; ;; 0xfff6
const ERR_TIMELOCK_NOT_EXPIRED            = 65527; ;; 0xfff7
const ERR_INVALID_OPERATION               = 65535; ;; 0xffff
const ERR_SWAP_NOT_FOUND                  = 65520; ;; 0xfff0
const ERR_ALREADY_INITIALIZED             = 65519; ;; 0xffef

;; -----------------------------------------------------------------
;; Global Variables (persistent storage)
;; -----------------------------------------------------------------
;; Storage now holds:
;;  - jettonWallet: address of the approved jetton token wallet contract
;;  - swapCounter: counter for swap IDs
;;  - swaps: dictionary of swap records
(slice, int, cell) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_msg_addr(),  ;; jettonWallet address
        ds~load_uint(64),    ;; swapCounter
        ds~load_dict()       ;; swaps dictionary
    );
}

() save_data(slice jettonWallet, int swapCounter, cell swaps) impure inline {
    set_data(
        begin_cell()
            .store_slice(jettonWallet)
            .store_uint(swapCounter, 64)
            .store_dict(swaps)
            .end_cell()
    );
}

;; -----------------------------------------------------------------
;; Initialize contract storage
;; -----------------------------------------------------------------
() initialize_storage(slice in_msg_body) impure {
    var (cur_jettonWallet, cur_swapCounter, cur_swaps) = load_data();
    
    ;; Ensure the contract isnâ€™t already initialized
    throw_if(ERR_ALREADY_INITIALIZED, cur_jettonWallet.preload_uint(2) != 0);
    
    ;; Read the jetton token wallet address from the message body
    slice jettonWallet = in_msg_body~load_msg_addr();
    
    int swapCounter = 0;
    cell swaps = new_dict();
    
    save_data(jettonWallet, swapCounter, swaps);
}

;; -----------------------------------------------------------------
;; Helpers
;; -----------------------------------------------------------------

;; Helper: compute sha256 of a 256-bit integer
int sha256_int256(int x) inline {
    builder b = begin_cell();
    b = b.store_uint(x, 256);
    cell c = b.end_cell();
    return cell_hash(c);
}

;; Helpers to serialize/deserialize a Swap record.
;; Note: We now store the token amount as a 128-bit integer.
builder buildSwap(
    slice initiator,
    slice recipient,
    int tokenAmount,
    int hashLock,
    int timeLock,
    int isCompleted
) inline {
    return begin_cell()
        .store_slice(initiator)         ;; initiator address
        .store_slice(recipient)         ;; recipient address
        .store_uint(tokenAmount, 128)   ;; jetton token amount (128-bit)
        .store_uint(hashLock, 256)        ;; hashLock
        .store_uint(timeLock, 64)         ;; timeLock
        .store_uint(isCompleted, 1)       ;; isCompleted flag
    ;
}

(slice, slice, int, int, int, int) parseSwap(slice s) inline {
    return (
        s~load_msg_addr(),       ;; initiator address
        s~load_msg_addr(),       ;; recipient address
        s~load_uint(128),        ;; tokenAmount (128-bit)
        s~load_uint(256),        ;; hashLock
        s~load_uint(64),         ;; timeLock
        s~load_uint(1)           ;; isCompleted flag (0 or 1)
    );
}

;; -----------------------------------------------------------------
;; GETTERS (for off-chain calls)
;; -----------------------------------------------------------------

int get_swap_counter() method_id {
    var (_, swapCounter, _) = load_data();
    ~dump(242424);
    ~dump(swapCounter);
    return swapCounter;
}

slice get_jetton_wallet() method_id {
    var (jettonWallet, _, _) = load_data();
    return jettonWallet;
}

int has_swap(int swapId) method_id {
    var (_, _, swaps) = load_data();
    var (_, found) = swaps.udict_get?(256, swapId);
    return found ? 1 : 0;
}

(slice, slice, int, int, int, int) get_swap(int swapId) method_id {
    var (_, _, swaps) = load_data();
    var (swapData, found) = swaps.udict_get?(256, swapId);
    throw_unless(ERR_SWAP_NOT_FOUND, found);
    return parseSwap(swapData);
}

;; -----------------------------------------------------------------
;; Operation Handlers (jetton-only)
;; -----------------------------------------------------------------

;; onJettonTransfer: Called when the contract receives a jetton token transfer.
;; Expected message structure:
;;   [ tokenSender address,
;;     tokenAmount (128-bit),
;;     remainingGasTo address,
;;     payload ref ]
;; The payload must contain:
;;   - hashLock (256-bit)
;;   - timeLock (64-bit)
() onJettonTransfer(slice in_msg_body) impure {
    var (jettonWallet, swapCounter, swaps) = load_data();
    
    slice tokenSender = in_msg_body~load_msg_addr();
    int tokenAmount = in_msg_body~load_uint(128);
    slice remainingGasTo = in_msg_body~load_msg_addr();
    cell payload = in_msg_body~load_ref();
    slice payloadSlice = payload.begin_parse();
    
    int hashLock = payloadSlice~load_uint(256);
    int timeLock = payloadSlice~load_uint(64);
    
    ;; For this example, we set both the initiator and recipient to remainingGasTo.
    slice initiator = remainingGasTo;
    slice recipient = remainingGasTo;
    
    builder b = buildSwap(initiator, recipient, tokenAmount, hashLock, timeLock, 0);
    swaps~udict_set(256, swapCounter, b.end_cell().begin_parse());
    
    save_data(jettonWallet, swapCounter + 1, swaps);
}

() completeSwap(slice in_msg_body) impure {
    ~strdump("COMPLETE SWAP - ENTER");

    var (jettonWallet, swapCounter, swaps) = load_data();
    
    int swapId = in_msg_body~load_uint(256);
    int preimage = in_msg_body~load_uint(256);
    
    ~strdump("SwapId received:");
    ~dump(swapId);
    ~strdump("Preimage received:");
    ~dump(preimage);
    
    var (swapData, found) = swaps.udict_get?(256, swapId);
    if (found == 0) {
        ~strdump("ERROR: Swap not found for swapId:");
        ~dump(swapId);
    }
    throw_unless(ERR_SWAP_NOT_FOUND, found);
    
    var (initiator, recipient, tokenAmount,
         hashLock, timeLock, isCompleted) = parseSwap(swapData);
    
    ~strdump("Swap details:");
    ~strdump("Initiator:");
    ~dump(initiator);
    ~strdump("Recipient:");
    ~dump(recipient);
    ~strdump("Token Amount:");
    ~dump(tokenAmount);
    ~strdump("Stored hashLock:");
    ~dump(hashLock);
    ~strdump("TimeLock:");
    ~dump(timeLock);
    ~strdump("IsCompleted:");
    ~dump(isCompleted);
    
    if (isCompleted) {
        ~strdump("ERROR: Swap already completed");
    }
    throw_if(ERR_SWAP_COMPLETED, isCompleted);
    
    int calculatedHash = sha256_int256(preimage);
    ~strdump("Calculated hash from preimage:");
    ~dump(calculatedHash);
    if (calculatedHash != hashLock) {
        ~strdump("ERROR: Invalid preimage. Expected hashLock:");
        ~dump(hashLock);
        ~strdump("but calculated:");
        ~dump(calculatedHash);
    }
    throw_unless(ERR_INVALID_PREIMAGE, calculatedHash == hashLock);
    
    if (now() >= timeLock) {
       ~strdump("ERROR: Timelock expired. Now:");
       ~dump(now());
       ~strdump("TimeLock:");
       ~dump(timeLock);
    }
    throw_if(ERR_TIMELOCK_EXPIRED, now() >= timeLock);
    
    ~strdump("Marking swap as completed");
    builder newSwap = buildSwap(initiator, recipient, tokenAmount, hashLock, timeLock, 1);
    swaps~udict_set(256, swapId, newSwap.end_cell().begin_parse());
    
    save_data(jettonWallet, swapCounter, swaps);
    ~strdump("Swap marked as completed and data saved");
    
    ;; Build and send a jetton transfer message to the recipient.
    ;; Here the outer cell is a standard message header, and the inner cell
    ;; uses op code 0x7362d09c as an example for a jetton transfer call.
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(jettonWallet)
        .store_coins(0)         ;; native coins are only used for gas
        .store_uint(0, 107)
        .store_ref(
            begin_cell()
                .store_uint(0x7362d09c, 32)  ;; jetton transfer op code (example)
                .store_slice(recipient)
                .store_uint(tokenAmount, 128) ;; token amount (128-bit)
                .end_cell()
        );
    send_raw_message(msg.end_cell(), 64);
    ~strdump("Jetton transfer message sent");
}

() refundSwap(slice in_msg_body) impure {
    var (jettonWallet, swapCounter, swaps) = load_data();
    
    int swapId = in_msg_body~load_uint(256);
    
    var (swapData, found) = swaps.udict_get?(256, swapId);
    throw_unless(ERR_SWAP_NOT_FOUND, found);
    
    var (initiator, recipient, tokenAmount,
         hashLock, timeLock, isCompleted) = parseSwap(swapData);
    
    throw_if(ERR_SWAP_ALREADY_COMPLETED_REFUND, isCompleted);
    throw_if(ERR_TIMELOCK_NOT_EXPIRED, now() < timeLock);
    
    ;; Build and send a jetton refund message back to the initiator.
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(jettonWallet)
        .store_coins(0)
        .store_uint(0, 107)
        .store_ref(
            begin_cell()
                .store_uint(0x7362d09c, 32)
                .store_slice(initiator)
                .store_uint(tokenAmount, 128)
                .end_cell()
        );
    send_raw_message(msg.end_cell(), 64);
}

;; -----------------------------------------------------------------
;; The main entry point
;; -----------------------------------------------------------------
() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    
    ;; Read the first 32 bits to check for an op code.
    int op = in_msg_body~load_uint(32);
    
    if (op == OP_INITIALIZE) {
        initialize_storage(in_msg_body);
        return ();
    }
    
    if (op == OP_COMPLETE_SWAP) {
        completeSwap(in_msg_body);
        return ();
    }
    
    if (op == OP_REFUND_SWAP) {
        refundSwap(in_msg_body);
        return ();
    }
    
    ;; If none of the above op codes match, assume the message is a jetton transfer.
    onJettonTransfer(in_msg_body);
}
